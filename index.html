<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Intelligent String Art Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for a better look and feel */
        body {
            font-family: 'Inter', sans-serif;
        }
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap');
        .control-panel {
            background-color: #1a1a1a;
        }
        .canvas-container, .build-instructions-container {
            background-color: #2a2a2a;
        }
        label {
            color: #a0aec0; /* Cool gray */
        }
        input[type="number"], input[type="file"] {
            background-color: #2d3748; /* Darker gray */
            color: #e2e8f0; /* Light gray */
            border: 1px solid #4a5568; /* Gray border */
        }
        button {
            transition: all 0.2s ease-in-out;
        }
        button:disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }
        canvas {
            border: 2px dashed #4a5568;
        }
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .divider {
            display: flex;
            align-items: center;
            text-align: center;
            color: #4a5568;
            margin: 1.5rem 0;
        }
        .divider::before, .divider::after {
            content: '';
            flex: 1;
            border-bottom: 1px solid #4a5568;
        }
        .divider:not(:empty)::before {
            margin-right: .5em;
        }
        .divider:not(:empty)::after {
            margin-left: .5em;
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex flex-col min-h-screen">

    <div class="flex flex-col lg:flex-row flex-grow">
        <!-- CONTROLS PANEL -->
        <div class="control-panel w-full lg:w-80 p-6 shadow-2xl flex-shrink-0 overflow-y-auto">
            <h1 class="text-2xl font-bold text-gray-200 mb-2">String Art Generator</h1>
            <p class="text-sm text-gray-400 mb-6">Create new artwork from an image.</p>

            <div class="space-y-6">
                <div>
                    <label for="image-upload" class="block text-sm font-medium mb-2">1. Upload Image</label>
                    <input type="file" id="image-upload" accept="image/*" class="w-full text-sm rounded-lg cursor-pointer p-2.5">
                </div>

                <div>
                    <label for="pins" class="block text-sm font-medium mb-2">2. Number of Pins</label>
                    <input type="number" id="pins" value="256" class="w-full rounded-lg p-2.5">
                </div>

                <div>
                    <label for="strings" class="block text-sm font-medium mb-2">3. Number of Strings</label>
                    <input type="number" id="strings" value="3000" class="w-full rounded-lg p-2.5">
                </div>
                 <div>
                    <label for="canvas-size" class="block text-sm font-medium mb-2">4. Canvas Size (inches)</label>
                    <input type="number" id="canvas-size" value="24" class="w-full rounded-lg p-2.5">
                </div>
                 <div>
                    <label for="thread-width" class="block text-sm font-medium mb-2">5. Thread Width (mm)</label>
                    <input type="number" id="thread-width" value="0.5" step="0.1" class="w-full rounded-lg p-2.5">
                </div>

                <button id="start-btn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg shadow-md disabled:bg-blue-800">
                    Generate Artwork
                </button>

                <div class="divider">OR</div>

                <p class="text-sm text-gray-400 -mt-2 mb-2">Load an existing build guide.</p>
                <div>
                    <label for="sequence-upload" class="block text-sm font-medium mb-2">Upload Pin Sequence (.txt)</label>
                    <input type="file" id="sequence-upload" accept=".txt" class="w-full text-sm rounded-lg cursor-pointer p-2.5">
                </div>
                 <button id="load-sequence-btn" class="w-full bg-teal-600 hover:bg-teal-700 text-white font-bold py-3 px-4 rounded-lg shadow-md disabled:bg-teal-800">
                    Load Guide
                </button>

                <div id="status" class="text-center text-gray-400 text-sm h-10 flex items-center justify-center">
                    <p id="status-text">Please upload an image.</p>
                    <div id="loader" class="loader hidden"></div>
                </div>
            </div>

        </div>

        <!-- MAIN CONTENT AREA -->
        <div class="flex-grow flex flex-col overflow-auto">
            <!-- CANVAS AREA -->
            <div class="canvas-container p-6 grid grid-cols-1 md:grid-cols-2 gap-6 items-center justify-center">
                <div class="text-center">
                    <h2 class="text-lg font-semibold mb-3 text-gray-300">Original (Grayscale)</h2>
                    <canvas id="original-canvas" width="500" height="500" class="mx-auto rounded-lg shadow-lg"></canvas>
                </div>
                <div class="text-center">
                    <h2 class="text-lg font-semibold mb-3 text-gray-300">Generated String Art</h2>
                    <canvas id="string-art-canvas" width="500" height="500" class="mx-auto rounded-lg shadow-lg bg-white"></canvas>
                </div>
            </div>
            
            <!-- BUILD INSTRUCTIONS SECTION (Combined) -->
            <div id="build-instructions-container" class="build-instructions-container p-6 hidden">
                 <h2 class="text-2xl font-bold text-center text-gray-200 mb-4">Build Instructions</h2>
                 
                 <!-- VISUALIZER -->
                 <div class="max-w-3xl mx-auto bg-gray-800 rounded-lg p-4 shadow-lg">
                    <div class="grid grid-cols-2 gap-4 text-gray-300 mb-4 border-b border-gray-700 pb-2">
                        <div>Total Strings: <span id="total-strings" class="font-bold text-white">0</span></div>
                        <div class="text-right">Est. Thread Length: <span id="thread-length" class="font-bold text-white">0 ft / 0 m</span></div>
                    </div>
                    <canvas id="visualizer-canvas" width="600" height="600" class="mx-auto rounded-lg bg-gray-700"></canvas>
                    <div class="text-center mt-4">
                        <p class="text-lg font-semibold text-gray-200">Connect Pin <span id="from-pin" class="text-xl text-yellow-400">1</span> to Pin <span id="to-pin" class="text-xl text-yellow-400">1</span></p>
                        <div class="flex items-center justify-center mt-2 space-x-4">
                            <button id="prev-step-btn" class="bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-6 rounded-lg">&lt; Prev</button>
                            <p id="step-counter" class="text-gray-400">Step 1 of 3000</p>
                            <button id="next-step-btn" class="bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-6 rounded-lg">Next &gt;</button>
                        </div>
                    </div>
                 </div>

                 <!-- PIN SEQUENCE & DOWNLOADS -->
                 <div id="instructions-container" class="max-w-3xl mx-auto mt-8">
                    <h2 class="text-lg font-bold text-gray-200 mb-2">Pin Sequence</h2>
                    <p class="text-xs text-gray-400 mb-4">Follow this pin sequence. Pins are numbered 1 to N, starting at the 12 o'clock position and going clockwise.</p>
                    <textarea id="pin-sequence" readonly class="w-full h-32 bg-gray-800 text-gray-300 rounded-lg p-2 text-sm border border-gray-600 resize-none"></textarea>
                    <div class="flex space-x-2 mt-2">
                         <button id="download-btn" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg shadow-md">
                           Download Sequence (.txt)
                        </button>
                        <button id="print-template-btn" class="w-full bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-lg shadow-md">
                            Print Pin Template
                        </button>
                    </div>
               </div>
            </div>
        </div>
    </div>
    
    <script>
        // --- DOM ELEMENT REFERENCES ---
        const imageUpload = document.getElementById('image-upload');
        const sequenceUpload = document.getElementById('sequence-upload');
        const pinsInput = document.getElementById('pins');
        const stringsInput = document.getElementById('strings');
        const canvasSizeInput = document.getElementById('canvas-size');
        const threadWidthInput = document.getElementById('thread-width');
        const startBtn = document.getElementById('start-btn');
        const loadSequenceBtn = document.getElementById('load-sequence-btn');
        const statusText = document.getElementById('status-text');
        const loader = document.getElementById('loader');
        
        const instructionsContainer = document.getElementById('instructions-container');
        const pinSequenceTextarea = document.getElementById('pin-sequence');
        const downloadBtn = document.getElementById('download-btn');
        const printTemplateBtn = document.getElementById('print-template-btn');

        const originalCanvas = document.getElementById('original-canvas');
        const originalCtx = originalCanvas.getContext('2d');
        const stringArtCanvas = document.getElementById('string-art-canvas');
        const stringArtCtx = stringArtCanvas.getContext('2d', { willReadFrequently: true });
        
        const buildInstructionsContainer = document.getElementById('build-instructions-container');
        const visualizerCanvas = document.getElementById('visualizer-canvas');
        const visualizerCtx = visualizerCanvas.getContext('2d');
        const totalStringsEl = document.getElementById('total-strings');
        const threadLengthEl = document.getElementById('thread-length');
        const fromPinEl = document.getElementById('from-pin');
        const toPinEl = document.getElementById('to-pin');
        const prevStepBtn = document.getElementById('prev-step-btn');
        const nextStepBtn = document.getElementById('next-step-btn');
        const stepCounterEl = document.getElementById('step-counter');


        // --- GLOBAL STATE ---
        let targetImageData = null;
        let importanceMapData = null;
        let pins = [];
        let pinPath = [];
        let currentStep = 0;
        let precomputedLines = null;
        const CANVAS_SIZE = 500;

        // --- INITIALIZATION ---
        startBtn.disabled = true;
        loadSequenceBtn.disabled = true;

        // --- EVENT LISTENERS ---
        imageUpload.addEventListener('change', handleImageUpload);
        sequenceUpload.addEventListener('change', () => {
            loadSequenceBtn.disabled = !sequenceUpload.files[0];
        });
        startBtn.addEventListener('click', startGeneration);
        loadSequenceBtn.addEventListener('click', loadSequenceFromFile);
        downloadBtn.addEventListener('click', downloadInstructions);
        printTemplateBtn.addEventListener('click', printPinTemplate);
        prevStepBtn.addEventListener('click', () => updateVisualizerStep(currentStep - 1));
        nextStepBtn.addEventListener('click', () => updateVisualizerStep(currentStep + 1));

        // --- CORE FUNCTIONS ---

        /**
         * Handles the user uploading a text file with a pin sequence.
         */
        function loadSequenceFromFile() {
            const file = sequenceUpload.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                const text = e.target.result;
                // Parse numbers from text, supporting various delimiters (space, newline, comma, arrow)
                const loadedPinPath = text
                    .trim()
                    .split(/[\s,→\n\r]+/) 
                    .filter(n => n !== "") // Remove empty strings from split
                    .map(Number)
                    .map(n => n - 1); // Convert from 1-based to 0-based index

                if (loadedPinPath.some(isNaN) || loadedPinPath.length < 2) {
                    statusText.textContent = 'Invalid or empty sequence file.';
                    return;
                }
                
                setupBuildGuide(loadedPinPath, true); // Pass true to clear the art canvas
            };
            reader.readAsText(file);
        }
        
        /**
         * Sets up the build guide UI from a loaded or generated pin path.
         * @param {number[]} newPinPath - The array of pin numbers.
         * @param {boolean} shouldClearArt - Whether to clear the string art canvas.
         */
        function setupBuildGuide(newPinPath, shouldClearArt = false) {
            pinPath = newPinPath;

            // --- Update UI with info from the loaded path ---
            const numPins = Math.max(...pinPath) + 1;
            const numStrings = pinPath.length - 1;
            pinsInput.value = numPins;
            stringsInput.value = numStrings;
            
            // --- Recalculate necessary data ---
            generatePins(); // Crucial for distance calculation and visualization

            // --- Clear irrelevant displays if loading from file ---
            if (shouldClearArt) {
                originalCtx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
                stringArtCtx.fillStyle = 'white';
                stringArtCtx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            }

            // --- Populate instruction fields ---
            pinSequenceTextarea.value = pinPath.map(p => p + 1).join(' → ');
            
            // Calculate thread length
            const canvasSizeInches = parseFloat(canvasSizeInput.value);
            const scaleFactor = canvasSizeInches / CANVAS_SIZE;
            let totalLengthInches = 0;
            for (let i = 0; i < pinPath.length - 1; i++) {
                const p1 = pins[pinPath[i]];
                const p2 = pins[pinPath[i+1]];
                const distPixels = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
                totalLengthInches += distPixels * scaleFactor;
            }
            const totalLengthFeet = totalLengthInches / 12;
            const totalLengthMeters = totalLengthInches * 0.0254;
            
            // Update visualizer stats
            totalStringsEl.textContent = numStrings;
            threadLengthEl.textContent = `${totalLengthFeet.toFixed(1)} ft / ${totalLengthMeters.toFixed(1)} m`;
            
            // Show and initialize visualizer and instructions
            buildInstructionsContainer.classList.remove('hidden');
            updateVisualizerStep(0);
            
            statusText.textContent = 'Build guide ready.';
            if(shouldClearArt) statusText.textContent = 'Build guide loaded successfully.';
            
            loader.classList.add('hidden');
            startBtn.disabled = false;
        }


        /**
         * Handles the user uploading an image file.
         */
        function handleImageUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    processImage(img);
                    statusText.textContent = 'Ready to generate.';
                    startBtn.disabled = false;
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        /**
         * Processes the uploaded image: resizes, grayscales, and creates the importance map.
         */
        function processImage(img) {
            const aspectRatio = img.width / img.height;
            let drawWidth = CANVAS_SIZE;
            let drawHeight = CANVAS_SIZE;
            if (aspectRatio > 1) {
                drawHeight = CANVAS_SIZE / aspectRatio;
            } else {
                drawWidth = CANVAS_SIZE * aspectRatio;
            }
            const offsetX = (CANVAS_SIZE - drawWidth) / 2;
            const offsetY = (CANVAS_SIZE - drawHeight) / 2;

            originalCtx.fillStyle = 'white';
            originalCtx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            originalCtx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);

            const imageData = originalCtx.getImageData(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            const data = imageData.data;
            const grayscaleData = new Uint8ClampedArray(data.length);

            for (let i = 0; i < data.length; i += 4) {
                const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
                grayscaleData[i] = avg;
                grayscaleData[i + 1] = avg;
                grayscaleData[i + 2] = avg;
                grayscaleData[i + 3] = 255;
            }
            
            targetImageData = new Uint8ClampedArray(grayscaleData);
            const grayscaleImageData = new ImageData(grayscaleData, CANVAS_SIZE, CANVAS_SIZE);
            const sobelData = applySobelFilter(grayscaleImageData); 
            importanceMapData = new Float32Array(CANVAS_SIZE * CANVAS_SIZE);
            for(let i=0; i < sobelData.length; i+=4) {
                importanceMapData[i/4] = sobelData[i];
            }
            
            originalCtx.putImageData(grayscaleImageData, 0, 0);
        }
        
        /**
         * Applies a Sobel filter to detect edges and create the importance map.
         */
        function applySobelFilter(imageData) {
            const width = imageData.width;
            const height = imageData.height;
            const grayscaleData = new Uint8ClampedArray(width * height);
            for(let i=0; i<imageData.data.length; i+=4){
                grayscaleData[i/4] = imageData.data[i];
            }

            const sobelData = new Uint8ClampedArray(imageData.data.length);
            const kernelX = [[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]];
            const kernelY = [[-1, -2, -1], [0, 0, 0], [1, 2, 1]];

            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    let pixelX = 0;
                    let pixelY = 0;
                    for (let i = -1; i <= 1; i++) {
                        for (let j = -1; j <= 1; j++) {
                            const pixel = grayscaleData[(y + i) * width + (x + j)];
                            pixelX += pixel * kernelX[i + 1][j + 1];
                            pixelY += pixel * kernelY[i + 1][j + 1];
                        }
                    }
                    const magnitude = Math.sqrt(pixelX * pixelX + pixelY * pixelY);
                    const index = (y * width + x) * 4;
                    sobelData[index] = magnitude;
                    sobelData[index + 1] = magnitude;
                    sobelData[index + 2] = magnitude;
                    sobelData[index + 3] = 255;
                }
            }
            return sobelData;
        }


        /**
         * Calculates the positions of pins arranged in a circle.
         */
        function generatePins() {
            pins = [];
            const numPins = parseInt(pinsInput.value);
            const radius = CANVAS_SIZE / 2 - 10; // 10px padding for safety
            const center = CANVAS_SIZE / 2;

            for (let i = 0; i < numPins; i++) {
                const angle = (i / numPins) * 2 * Math.PI - (Math.PI / 2); // Start from 12 o'clock
                const x = Math.round(center + radius * Math.cos(angle));
                const y = Math.round(center + radius * Math.sin(angle));
                pins.push({ x, y });
            }
        }

        /**
         * Uses Bresenham's algorithm to find all pixels on a line between two points.
         */
        function getLinePixels(x0, y0, x1, y1) {
            const pixels = [];
            const dx = Math.abs(x1 - x0);
            const dy = Math.abs(y1 - y0);
            const sx = (x0 < x1) ? 1 : -1;
            const sy = (y0 < y1) ? 1 : -1;
            let err = dx - dy;

            while (true) {
                pixels.push(y0 * CANVAS_SIZE + x0);
                if ((x0 === x1) && (y0 === y1)) break;
                const e2 = 2 * err;
                if (e2 > -dy) { err -= dy; x0 += sx; }
                if (e2 < dx) { err += dx; y0 += sy; }
            }
            return pixels;
        }

        /**
         * Pre-computes all possible lines between pins for a massive speed boost.
         */
        function precomputeLines() {
            const numPins = pins.length;
            precomputedLines = new Array(numPins);
            for (let i = 0; i < numPins; i++) {
                precomputedLines[i] = new Array(numPins);
                for (let j = i + 1; j < numPins; j++) {
                    const line = getLinePixels(pins[i].x, pins[i].y, pins[j].x, pins[j].y);
                    precomputedLines[i][j] = line;
                }
            }
        }

        /**
         * Calculates the "goodness" of a potential line based on the weighted error it reduces.
         */
        function calculatePerceptualImprovement(linePixels, currentCanvasData) {
            let errorBefore = 0;
            let errorAfter = 0;
            const stringDarkness = 255 * 0.1; 

            for (const pixelIndex of linePixels) {
                const i = pixelIndex * 4;
                const weight = 1 + importanceMapData[pixelIndex] / 64; 

                const currentVal = currentCanvasData[i];
                const targetVal = targetImageData[i];
                const error = currentVal - targetVal;
                errorBefore += (error * error) * weight;
                
                const newVal = Math.max(0, currentVal - stringDarkness);
                const newError = newVal - targetVal;
                errorAfter += (newError * newError) * weight;
            }
            return errorBefore - errorAfter;
        }
        
        /**
         * The main entry point to start the string art generation process.
         */
        async function startGeneration() {
            if (!targetImageData) {
                statusText.textContent = 'Please upload an image first.';
                return;
            }

            // --- UI SETUP ---
            startBtn.disabled = true;
            statusText.classList.add('hidden');
            loader.classList.remove('hidden');
            buildInstructionsContainer.classList.add('hidden');
            let generatedPinPath = []; // Use a local variable for generation

            // --- GENERATION SETUP ---
            stringArtCtx.fillStyle = 'white';
            stringArtCtx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            generatePins();
            
            statusText.textContent = 'Pre-computing lines...';
            statusText.classList.remove('hidden');
            loader.classList.add('hidden');

            await new Promise(resolve => setTimeout(() => {
                precomputeLines();
                resolve();
            }, 50));

            loader.classList.remove('hidden');
            statusText.classList.add('hidden');

            // --- MAIN LOOP ---
            let currentPin = 0;
            generatedPinPath.push(currentPin);
            const numStrings = parseInt(stringsInput.value);
            const currentCanvasData = new Uint8ClampedArray(targetImageData.length);
            currentCanvasData.fill(255);

            const canvasSizeInches = parseFloat(canvasSizeInput.value);
            const threadWidthMM = parseFloat(threadWidthInput.value);
            const pixelsPerInch = CANVAS_SIZE / canvasSizeInches;
            const threadWidthInches = threadWidthMM / 25.4;
            const threadWidthPixels = Math.max(0.1, threadWidthInches * pixelsPerInch);

            let stringCount = 0;

            function generationStep() {
                if (stringCount >= numStrings) {
                    setupBuildGuide(generatedPinPath); // Finalize with the generated path
                    statusText.textContent = 'Generation complete!';
                    return;
                }

                if(stringCount % 10 === 0) {
                     statusText.textContent = `Processing string ${stringCount} of ${numStrings}`;
                }


                let bestNextPin = -1;
                let maxImprovement = -Infinity;

                for (let nextPin = 0; nextPin < pins.length; nextPin++) {
                    if (nextPin === currentPin || Math.abs(nextPin - currentPin) < 5) continue;
                    
                    const lineIndexI = Math.min(currentPin, nextPin);
                    const lineIndexJ = Math.max(currentPin, nextPin);
                    
                    const linePixels = precomputedLines[lineIndexI][lineIndexJ];
                    if(!linePixels) continue;

                    const improvement = calculatePerceptualImprovement(linePixels, currentCanvasData);

                    if (improvement > maxImprovement) {
                        maxImprovement = improvement;
                        bestNextPin = nextPin;
                    }
                }

                if (bestNextPin !== -1) {
                    stringArtCtx.beginPath();
                    stringArtCtx.moveTo(pins[currentPin].x, pins[currentPin].y);
                    stringArtCtx.lineTo(pins[bestNextPin].x, pins[bestNextPin].y);
                    stringArtCtx.strokeStyle = `rgba(0, 0, 0, 1.0)`;
                    stringArtCtx.lineWidth = threadWidthPixels;
                    stringArtCtx.stroke();
                    
                    const lineIndexI = Math.min(currentPin, bestNextPin);
                    const lineIndexJ = Math.max(currentPin, bestNextPin);
                    const linePixels = precomputedLines[lineIndexI][lineIndexJ];
                    const stringDarkness = 255 * 0.1;
                     for (const pixelIndex of linePixels) {
                        const i = pixelIndex * 4;
                        currentCanvasData[i] = Math.max(0, currentCanvasData[i] - stringDarkness);
                        currentCanvasData[i+1] = Math.max(0, currentCanvasData[i+1] - stringDarkness);
                        currentCanvasData[i+2] = Math.max(0, currentCanvasData[i+2] - stringDarkness);
                    }
                    
                    generatedPinPath.push(bestNextPin);
                    currentPin = bestNextPin;
                } else {
                   currentPin = Math.floor(Math.random() * pins.length);
                   generatedPinPath.push(currentPin); // Keep the path continuous even on a jump
                }

                stringCount++;
                requestAnimationFrame(generationStep);
            }

            statusText.textContent = `Processing string 0 of ${numStrings}`;
            statusText.classList.remove('hidden');
            loader.classList.add('hidden');
            requestAnimationFrame(generationStep);
        }
        
        /**
         * Updates the visualizer to show a specific step in the sequence.
         */
        function updateVisualizerStep(newStep) {
            const maxSteps = pinPath.length - 2;
            if (newStep < 0 || newStep > maxSteps) return; // Boundary check

            currentStep = newStep;
            
            const fromPin = pinPath[currentStep];
            const toPin = pinPath[currentStep + 1];

            // Update text and counters
            fromPinEl.textContent = fromPin + 1;
            toPinEl.textContent = toPin + 1;
            stepCounterEl.textContent = `Step ${currentStep + 1} of ${maxSteps + 1}`;

            // Update button states
            prevStepBtn.disabled = currentStep === 0;
            nextStepBtn.disabled = currentStep === maxSteps;

            // Draw the visualizer
            drawVisualizer();
        }

        /**
         * Draws the current state of the pin visualizer.
         */
        function drawVisualizer() {
            const vCanvas = visualizerCanvas;
            const ctx = visualizerCtx;
            const size = vCanvas.width;
            const center = size / 2;
            const radius = size / 2 - 20;

            ctx.clearRect(0, 0, size, size);

            // Draw all pins as dots
            const numPins = parseInt(pinsInput.value);
            for (let i = 0; i < numPins; i++) {
                const angle = (i / numPins) * 2 * Math.PI - (Math.PI / 2); // Start from 12 o'clock
                const x = center + radius * Math.cos(angle);
                const y = center + radius * Math.sin(angle);
                ctx.beginPath();
                ctx.arc(x, y, 2, 0, 2 * Math.PI);
                ctx.fillStyle = 'white';
                ctx.fill();
            }
            
            // Highlight and connect the current pins
            const fromPinIndex = pinPath[currentStep];
            const toPinIndex = pinPath[currentStep + 1];

            const angleFrom = (fromPinIndex / numPins) * 2 * Math.PI - (Math.PI / 2); // Start from 12 o'clock
            const fromX = center + radius * Math.cos(angleFrom);
            const fromY = center + radius * Math.sin(angleFrom);
            
            const angleTo = (toPinIndex / numPins) * 2 * Math.PI - (Math.PI / 2); // Start from 12 o'clock
            const toX = center + radius * Math.cos(angleTo);
            const toY = center + radius * Math.sin(angleTo);
            
            // Draw connecting line
            ctx.beginPath();
            ctx.moveTo(fromX, fromY);
            ctx.lineTo(toX, toY);
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 1.5;
            ctx.stroke();

            // Highlight from pin
            ctx.beginPath();
            ctx.arc(fromX, fromY, 5, 0, 2 * Math.PI);
            ctx.fillStyle = '#34D399'; // Green
            ctx.fill();

            // Highlight to pin
            ctx.beginPath();
            ctx.arc(toX, toY, 5, 0, 2 * Math.PI);
            ctx.fillStyle = '#FBBF24'; // Yellow
            ctx.fill();
        }


        /**
         * Downloads the generated pin sequence as a text file.
         */
        function downloadInstructions() {
            const text = pinSequenceTextarea.value;
            if (!text) return;

            const blob = new Blob([text.replace(/ → /g, '\n')], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'string_art_instructions.txt';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        /**
         * Generates a clean, minimalist pin template based on the user's preferred style.
         */
        function printPinTemplate() {
            const numPins = parseInt(pinsInput.value);
            if (isNaN(numPins) || numPins <= 0) {
                const originalStatus = statusText.textContent;
                statusText.textContent = "Please generate or load a sequence first.";
                setTimeout(() => { statusText.textContent = originalStatus; }, 3000);
                return;
            }

            const A4_WIDTH_PT = 595;
            const size = A4_WIDTH_PT; 
            const center = size / 2;
            const radius = size / 2 - 40; // Main circle where pins are hammered
            const textRadius = radius + 18;

            let svgContent = `<svg width="100%" height="100%" viewBox="0 0 ${size} ${size}" xmlns="http://www.w3.org/2000/svg" style="font-family: Arial, sans-serif;">`;
            
            // --- Guide Elements ---
            svgContent += `<line x1="${center - 10}" y1="${center}" x2="${center + 10}" y2="${center}" stroke="#ddd" stroke-width="0.5"/>`;
            svgContent += `<line x1="${center}" y1="${center - 10}" x2="${center}" y2="${center + 10}" stroke="#ddd" stroke-width="0.5"/>`;
            

            // --- Pins and Labels Loop ---
            for (let i = 0; i < numPins; i++) {
                const pinNumber = i + 1;
                const isMajorTick = pinNumber % 10 === 0;
                const isMinorTick = pinNumber % 5 === 0;

                const angle = (i / numPins) * 2 * Math.PI - (Math.PI / 2);
                
                // 1. Draw the tick mark
                const tickLength = isMajorTick ? 12 : (isMinorTick ? 8 : 4);
                const tickStartX = center + (radius - tickLength / 2) * Math.cos(angle);
                const tickStartY = center + (radius - tickLength / 2) * Math.sin(angle);
                const tickEndX = center + (radius + tickLength / 2) * Math.cos(angle);
                const tickEndY = center + (radius + tickLength / 2) * Math.sin(angle);
                
                svgContent += `<line x1="${tickStartX}" y1="${tickStartY}" x2="${tickEndX}" y2="${tickEndY}" stroke="black" stroke-width="${isMajorTick ? 0.8 : 0.5}"/>`;
                
                // 2. Determine if and how to draw the label
                if (pinNumber % 2 === 0 || isMajorTick) {
                    const isLabelMajor = isMajorTick; // Only 10s are major
                    const textX = center + textRadius * Math.cos(angle);
                    const textY = center + textRadius * Math.sin(angle);
                    const rotation = (angle * 180 / Math.PI) + 90;

                    svgContent += `<text x="${textX}" y="${textY}" 
                        font-size="${isLabelMajor ? 11 : 8}" 
                        font-weight="${isLabelMajor ? 'bold' : 'normal'}" 
                        text-anchor="middle" 
                        dominant-baseline="middle" 
                        fill="${isLabelMajor ? '#000' : '#444'}"
                        transform="rotate(${rotation} ${textX} ${textY})">${pinNumber}</text>`;
                }
            }
            
            svgContent += `</svg>`;

            // --- Open Print Preview Window ---
            const printWindow = window.open('', '_blank');
            printWindow.document.write('<!DOCTYPE html><html><head><title>String Art Pin Template</title>');
            printWindow.document.write(`
                <style>
                    @media print {
                        @page { size: portrait; margin: 0.5cm; }
                        body { margin: 0; padding: 0; }
                        .no-print { display: none; }
                        svg { width: 100%; height: auto; max-width: 20cm; max-height: 28.7cm; }
                    }
                    body { 
                        margin: 0; padding: 20px; text-align: center; font-family: sans-serif;
                        background-color: #f4f4f4; display: flex; flex-direction: column;
                        align-items: center; justify-content: flex-start; height: 100vh;
                        box-sizing: border-box;
                    }
                    svg { 
                        border: 1px solid #ccc; background-color: white;
                        box-shadow: 0 4px 8px rgba(0,0,0,0.1);
                        max-width: calc(100% - 40px); max-height: calc(100vh - 120px);
                    }
                    .controls {
                        margin-bottom: 20px; padding: 10px; background-color: white;
                        border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                    }
                    button {
                        padding: 10px 20px; font-size: 16px; cursor: pointer;
                        border: 1px solid #ccc; background-color: #f0f0f0;
                        border-radius: 5px; margin: 0 10px;
                    }
                    button:hover { background-color: #e0e0e0; }
                </style>
            `);
            printWindow.document.write('</head><body>');
            printWindow.document.write('<div class="controls no-print"><button onclick="window.print()">Print</button> <button onclick="window.close()">Close</button></div>');
            printWindow.document.write(svgContent);
            printWindow.document.write('</body></html>');
            
            printWindow.document.close();
            printWindow.focus();
        }
    </script>
</body>
</html>


<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Intelligent String Art Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for a better look and feel */
        body {
            font-family: 'Inter', sans-serif;
        }
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap');
        .control-panel {
            background-color: #1a1a1a;
        }
        .canvas-container {
            background-color: #2a2a2a;
        }
        label {
            color: #a0aec0; /* Cool gray */
        }
        input[type="number"], input[type="file"] {
            background-color: #2d3748; /* Darker gray */
            color: #e2e8f0; /* Light gray */
            border: 1px solid #4a5568; /* Gray border */
        }
        button {
            transition: all 0.2s ease-in-out;
        }
        button:disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }
        canvas {
            border: 2px dashed #4a5568;
        }
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex flex-col lg:flex-row min-h-screen">

    <!-- CONTROLS PANEL -->
    <div class="control-panel w-full lg:w-80 p-6 shadow-2xl flex-shrink-0 overflow-y-auto">
        <h1 class="text-2xl font-bold text-gray-200 mb-2">String Art Generator</h1>
        <p class="text-sm text-gray-400 mb-6">Based on the "Intelligent Greedy" algorithm.</p>

        <div class="space-y-6">
            <div>
                <label for="image-upload" class="block text-sm font-medium mb-2">1. Upload Image</label>
                <input type="file" id="image-upload" accept="image/*" class="w-full text-sm rounded-lg cursor-pointer p-2.5">
            </div>

            <div>
                <label for="pins" class="block text-sm font-medium mb-2">2. Number of Pins</label>
                <input type="number" id="pins" value="256" class="w-full rounded-lg p-2.5">
            </div>

            <div>
                <label for="strings" class="block text-sm font-medium mb-2">3. Number of Strings</label>
                <input type="number" id="strings" value="3000" class="w-full rounded-lg p-2.5">
            </div>
             <div>
                <label for="canvas-size" class="block text-sm font-medium mb-2">4. Canvas Size (inches)</label>
                <input type="number" id="canvas-size" value="24" class="w-full rounded-lg p-2.5">
            </div>
             <div>
                <label for="thread-width" class="block text-sm font-medium mb-2">5. Thread Width (mm)</label>
                <input type="number" id="thread-width" value="0.5" step="0.1" class="w-full rounded-lg p-2.5">
            </div>

            <button id="start-btn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg shadow-md disabled:bg-blue-800">
                Generate Artwork
            </button>

            <div id="status" class="text-center text-gray-400 text-sm h-10 flex items-center justify-center">
                <p id="status-text">Please upload an image.</p>
                <div id="loader" class="loader hidden"></div>
            </div>
        </div>

        <!-- INSTRUCTIONS SECTION -->
        <div id="instructions-container" class="mt-8 hidden">
            <h2 class="text-lg font-bold text-gray-200 mb-2">Threading Instructions</h2>
            <p class="text-xs text-gray-400 mb-4">Follow this pin sequence. Pins are numbered 0 to N-1, starting at the 3 o'clock position and going clockwise.</p>
            <textarea id="pin-sequence" readonly class="w-full h-32 bg-gray-800 text-gray-300 rounded-lg p-2 text-sm border border-gray-600 resize-none"></textarea>
            <button id="download-btn" class="w-full mt-2 bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg shadow-md">
               Download Instructions (.txt)
            </button>
       </div>
    </div>

    <!-- CANVAS AREA -->
    <div class="canvas-container flex-grow p-6 grid grid-cols-1 md:grid-cols-2 gap-6 items-center justify-center overflow-auto">
        <div class="text-center">
            <h2 class="text-lg font-semibold mb-3 text-gray-300">Original (Grayscale)</h2>
            <canvas id="original-canvas" width="500" height="500" class="mx-auto rounded-lg shadow-lg"></canvas>
        </div>
        <div class="text-center">
            <h2 class="text-lg font-semibold mb-3 text-gray-300">Generated String Art</h2>
            <canvas id="string-art-canvas" width="500" height="500" class="mx-auto rounded-lg shadow-lg bg-white"></canvas>
        </div>
    </div>

    <script>
        // --- DOM ELEMENT REFERENCES ---
        const imageUpload = document.getElementById('image-upload');
        const pinsInput = document.getElementById('pins');
        const stringsInput = document.getElementById('strings');
        const canvasSizeInput = document.getElementById('canvas-size');
        const threadWidthInput = document.getElementById('thread-width');
        const startBtn = document.getElementById('start-btn');
        const statusText = document.getElementById('status-text');
        const loader = document.getElementById('loader');
        const instructionsContainer = document.getElementById('instructions-container');
        const pinSequenceTextarea = document.getElementById('pin-sequence');
        const downloadBtn = document.getElementById('download-btn');

        const originalCanvas = document.getElementById('original-canvas');
        const originalCtx = originalCanvas.getContext('2d');
        const stringArtCanvas = document.getElementById('string-art-canvas');
        const stringArtCtx = stringArtCanvas.getContext('2d', { willReadFrequently: true });


        // --- GLOBAL STATE ---
        let targetImageData = null;
        let importanceMapData = null;
        let pins = [];
        let precomputedLines = null;
        const CANVAS_SIZE = 500;

        // --- INITIALIZATION ---
        startBtn.disabled = true;

        // --- EVENT LISTENERS ---
        imageUpload.addEventListener('change', handleImageUpload);
        startBtn.addEventListener('click', startGeneration);
        downloadBtn.addEventListener('click', downloadInstructions);

        // --- CORE FUNCTIONS ---

        /**
         * Handles the user uploading an image file.
         */
        function handleImageUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    processImage(img);
                    statusText.textContent = 'Ready to generate.';
                    startBtn.disabled = false;
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        /**
         * Processes the uploaded image: resizes, grayscales, and creates the importance map.
         * @param {Image} img - The uploaded image object.
         */
        function processImage(img) {
            // Resize and draw the image
            const aspectRatio = img.width / img.height;
            let drawWidth = CANVAS_SIZE;
            let drawHeight = CANVAS_SIZE;
            if (aspectRatio > 1) {
                drawHeight = CANVAS_SIZE / aspectRatio;
            } else {
                drawWidth = CANVAS_SIZE * aspectRatio;
            }
            const offsetX = (CANVAS_SIZE - drawWidth) / 2;
            const offsetY = (CANVAS_SIZE - drawHeight) / 2;

            originalCtx.fillStyle = 'white';
            originalCtx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            originalCtx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);

            // Get image data, grayscale it
            const imageData = originalCtx.getImageData(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            const data = imageData.data;
            const grayscaleData = new Uint8ClampedArray(data.length);

            for (let i = 0; i < data.length; i += 4) {
                const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
                grayscaleData[i] = avg;
                grayscaleData[i + 1] = avg;
                grayscaleData[i + 2] = avg;
                grayscaleData[i + 3] = 255;
            }
            
            // The target for the algorithm is the standard grayscale image.
            // It will try to make the white canvas match this target by adding black threads.
            targetImageData = new Uint8ClampedArray(grayscaleData);

            // Create the Sobel-based importance map from the standard grayscale image
            const grayscaleImageData = new ImageData(grayscaleData, CANVAS_SIZE, CANVAS_SIZE);
            const sobelData = applySobelFilter(grayscaleImageData); 
            importanceMapData = new Float32Array(CANVAS_SIZE * CANVAS_SIZE);
            for(let i=0; i < sobelData.length; i+=4) {
                importanceMapData[i/4] = sobelData[i];
            }
            
            // Display the NORMAL grayscale image for user reference
            originalCtx.putImageData(grayscaleImageData, 0, 0);
        }
        
        /**
         * Applies a Sobel filter to detect edges and create the importance map.
         * @param {ImageData} imageData - The grayscale image data.
         * @returns {Uint8ClampedArray} The data for the edge map.
         */
        function applySobelFilter(imageData) {
            const width = imageData.width;
            const height = imageData.height;
            const grayscaleData = new Uint8ClampedArray(width * height);
            for(let i=0; i<imageData.data.length; i+=4){
                grayscaleData[i/4] = imageData.data[i];
            }

            const sobelData = new Uint8ClampedArray(imageData.data.length);
            const kernelX = [[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]];
            const kernelY = [[-1, -2, -1], [0, 0, 0], [1, 2, 1]];

            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    let pixelX = 0;
                    let pixelY = 0;
                    for (let i = -1; i <= 1; i++) {
                        for (let j = -1; j <= 1; j++) {
                            const pixel = grayscaleData[(y + i) * width + (x + j)];
                            pixelX += pixel * kernelX[i + 1][j + 1];
                            pixelY += pixel * kernelY[i + 1][j + 1];
                        }
                    }
                    const magnitude = Math.sqrt(pixelX * pixelX + pixelY * pixelY);
                    const index = (y * width + x) * 4;
                    sobelData[index] = magnitude;
                    sobelData[index + 1] = magnitude;
                    sobelData[index + 2] = magnitude;
                    sobelData[index + 3] = 255;
                }
            }
            return sobelData;
        }


        /**
         * Calculates the positions of pins arranged in a circle.
         */
        function generatePins() {
            pins = [];
            const numPins = parseInt(pinsInput.value);
            const radius = CANVAS_SIZE / 2 - 5; // 5px padding
            const center = CANVAS_SIZE / 2;

            for (let i = 0; i < numPins; i++) {
                const angle = (i / numPins) * 2 * Math.PI;
                const x = Math.round(center + radius * Math.cos(angle));
                const y = Math.round(center + radius * Math.sin(angle));
                pins.push({ x, y });
            }
        }

        /**
         * Uses Bresenham's algorithm to find all pixels on a line between two points.
         * @returns {Array<number>} An array of pixel indices.
         */
        function getLinePixels(x0, y0, x1, y1) {
            const pixels = [];
            const dx = Math.abs(x1 - x0);
            const dy = Math.abs(y1 - y0);
            const sx = (x0 < x1) ? 1 : -1;
            const sy = (y0 < y1) ? 1 : -1;
            let err = dx - dy;

            while (true) {
                pixels.push(y0 * CANVAS_SIZE + x0);
                if ((x0 === x1) && (y0 === y1)) break;
                const e2 = 2 * err;
                if (e2 > -dy) { err -= dy; x0 += sx; }
                if (e2 < dx) { err += dx; y0 += sy; }
            }
            return pixels;
        }

        /**
         * Pre-computes all possible lines between pins for a massive speed boost.
         */
        function precomputeLines() {
            const numPins = pins.length;
            precomputedLines = new Array(numPins);
            for (let i = 0; i < numPins; i++) {
                precomputedLines[i] = new Array(numPins);
                for (let j = i + 1; j < numPins; j++) {
                    const line = getLinePixels(pins[i].x, pins[i].y, pins[j].x, pins[j].y);
                    precomputedLines[i][j] = line;
                    // precomputedLines[j][i] = line; // Lines are symmetrical
                }
            }
        }

        /**
         * Calculates the "goodness" of a potential line based on the weighted error it reduces.
         * @param {Array<number>} linePixels - Indices of pixels on the line.
         * @param {Uint8ClampedArray} currentCanvasData - The current state of the generated art.
         * @returns {number} The score (error reduction) for this line.
         */
        function calculatePerceptualImprovement(linePixels, currentCanvasData) {
            let errorBefore = 0;
            let errorAfter = 0;
            // Simulate the impact of one string. We use a small value to guide the algorithm.
            const stringDarkness = 255 * 0.1; 

            for (const pixelIndex of linePixels) {
                const i = pixelIndex * 4;
                const weight = 1 + importanceMapData[pixelIndex] / 64; // Add weight from edge map

                const currentVal = currentCanvasData[i];
                const targetVal = targetImageData[i];
                
                const error = currentVal - targetVal;

                errorBefore += (error * error) * weight;
                
                // Subtract darkness from the current canvas value
                const newVal = Math.max(0, currentVal - stringDarkness);
                const newError = newVal - targetVal;

                errorAfter += (newError * newError) * weight;
            }

            return errorBefore - errorAfter;
        }

        /**
         * The main entry point to start the string art generation process.
         */
        async function startGeneration() {
            if (!targetImageData) {
                alert("Please upload an image first.");
                return;
            }

            // --- UI SETUP ---
            startBtn.disabled = true;
            statusText.classList.add('hidden');
            loader.classList.remove('hidden');
            instructionsContainer.classList.add('hidden');

            // --- GENERATION SETUP ---
            stringArtCtx.fillStyle = 'white';
            stringArtCtx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            generatePins();
            
            // Show a brief message for pre-computation
            statusText.textContent = 'Pre-computing lines...';
            statusText.classList.remove('hidden');
            loader.classList.add('hidden');

            await new Promise(resolve => setTimeout(() => {
                precomputeLines();
                resolve();
            }, 50));

            loader.classList.remove('hidden');
            statusText.classList.add('hidden');

            // --- MAIN LOOP ---
            let currentPin = 0;
            const pinPath = [currentPin]; // To store the sequence of pins
            const numStrings = parseInt(stringsInput.value);
            const currentCanvasData = new Uint8ClampedArray(targetImageData.length);
            currentCanvasData.fill(255); // Start with a white canvas in memory

            // Calculate line width in pixels for drawing
            const canvasSizeInches = parseFloat(canvasSizeInput.value);
            const threadWidthMM = parseFloat(threadWidthInput.value);
            const pixelsPerInch = CANVAS_SIZE / canvasSizeInches;
            const threadWidthInches = threadWidthMM / 25.4;
            const threadWidthPixels = Math.max(0.1, threadWidthInches * pixelsPerInch); // Allow for sub-pixel rendering

            let stringCount = 0;

            function generationStep() {
                if (stringCount >= numStrings) {
                    statusText.textContent = 'Generation complete!';
                    statusText.classList.remove('hidden');
                    loader.classList.add('hidden');
                    startBtn.disabled = false;
                    // Show instructions
                    pinSequenceTextarea.value = pinPath.join(' → ');
                    instructionsContainer.classList.remove('hidden');
                    return;
                }

                // Update status every 10 strings for better UI performance
                if(stringCount % 10 === 0) {
                     statusText.textContent = `Processing string ${stringCount} of ${numStrings}`;
                }


                let bestNextPin = -1;
                let maxImprovement = -Infinity;

                // Find the best next string from the current pin
                for (let nextPin = 0; nextPin < pins.length; nextPin++) {
                    if (nextPin === currentPin || Math.abs(nextPin - currentPin) < 5) continue; // Avoid trivial lines
                    
                    const lineIndexI = Math.min(currentPin, nextPin);
                    const lineIndexJ = Math.max(currentPin, nextPin);
                    
                    const linePixels = precomputedLines[lineIndexI][lineIndexJ];
                    if(!linePixels) continue;

                    const improvement = calculatePerceptualImprovement(linePixels, currentCanvasData);

                    if (improvement > maxImprovement) {
                        maxImprovement = improvement;
                        bestNextPin = nextPin;
                    }
                }

                if (bestNextPin !== -1) {
                    // Draw the winning line on the canvas
                    stringArtCtx.beginPath();
                    stringArtCtx.moveTo(pins[currentPin].x, pins[currentPin].y);
                    stringArtCtx.lineTo(pins[bestNextPin].x, pins[bestNextPin].y);
                    stringArtCtx.strokeStyle = `rgba(0, 0, 0, 1.0)`; // Now fully opaque black
                    stringArtCtx.lineWidth = threadWidthPixels;
                    stringArtCtx.stroke();
                    
                    // Update our in-memory representation of the canvas
                    const lineIndexI = Math.min(currentPin, bestNextPin);
                    const lineIndexJ = Math.max(currentPin, bestNextPin);
                    const linePixels = precomputedLines[lineIndexI][lineIndexJ];
                    const stringDarkness = 255 * 0.1; // Consistent simulation impact
                     for (const pixelIndex of linePixels) {
                        const i = pixelIndex * 4;
                        currentCanvasData[i] = Math.max(0, currentCanvasData[i] - stringDarkness);
                        currentCanvasData[i+1] = Math.max(0, currentCanvasData[i+1] - stringDarkness);
                        currentCanvasData[i+2] = Math.max(0, currentCanvasData[i+2] - stringDarkness);
                    }
                    
                    pinPath.push(bestNextPin);
                    currentPin = bestNextPin;
                } else {
                   // If no improvement found, jump to a random pin to avoid getting stuck
                   currentPin = Math.floor(Math.random() * pins.length);
                }

                stringCount++;
                requestAnimationFrame(generationStep);
            }

            statusText.textContent = `Processing string 0 of ${numStrings}`;
            statusText.classList.remove('hidden');
            loader.classList.add('hidden');

            // Kick off the animation loop
            requestAnimationFrame(generationStep);
        }

        /**
         * Downloads the generated pin sequence as a text file.
         */
        function downloadInstructions() {
            const text = pinSequenceTextarea.value;
            if (!text) return;

            const blob = new Blob([text.replace(/ → /g, '\n')], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'string_art_instructions.txt';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
    </script>
</body>
</html>


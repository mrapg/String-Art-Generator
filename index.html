<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Intelligent Greedy String Art Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap');
        .control-panel {
            background-color: #1a1a1a;
        }
        .canvas-container {
            background-color: #2a2a2a;
        }
        label {
            color: #a0aec0;
        }
        input[type="number"], input[type="file"] {
            background-color: #2d3748;
            color: #e2e8f0;
            border: 1px solid #4a5568;
        }
        button:disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }
        canvas {
            border: 2px dashed #4a5568;
        }
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3b82f6;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex flex-col lg:flex-row min-h-screen">

    <!-- CONTROLS PANEL -->
    <div class="control-panel w-full lg:w-96 p-6 shadow-2xl flex-shrink-0 overflow-y-auto">
        <h1 class="text-2xl font-bold text-gray-200 mb-2">Tier 1 String Art</h1>
        <p class="text-sm text-gray-400 mb-6">A fast and reliable sequential algorithm for high-quality results.</p>

        <div class="space-y-6">
            <div>
                <label for="image-upload" class="block text-sm font-medium mb-2">1. Upload Image</label>
                <input type="file" id="image-upload" accept="image/*" class="w-full text-sm rounded-lg cursor-pointer p-2.5">
            </div>

            <div class="grid grid-cols-2 gap-4">
                <div>
                    <label for="pins" class="block text-sm font-medium mb-2">2. Pins</label>
                    <input type="number" id="pins" value="256" class="w-full rounded-lg p-2.5">
                </div>
                 <div>
                    <label for="thread-count" class="block text-sm font-medium mb-2">3. Threads</label>
                    <input type="number" id="thread-count" value="3000" class="w-full rounded-lg p-2.5">
                </div>
            </div>
             <div>
                <label for="canvas-size" class="block text-sm font-medium mb-2">4. Canvas Size (inches)</label>
                <input type="number" id="canvas-size" value="24" class="w-full rounded-lg p-2.5">
            </div>
             <div>
                <label for="thread-width" class="block text-sm font-medium mb-2">5. Thread Width (mm)</label>
                <input type="number" id="thread-width" value="0.5" step="0.1" class="w-full rounded-lg p-2.5">
            </div>

            <div class="flex items-center space-x-4">
                <button id="start-btn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg shadow-md transition-all">
                    Generate
                </button>
                 <button id="stop-btn" class="w-full bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-4 rounded-lg shadow-md transition-all hidden">
                    Stop
                </button>
            </div>

            <div id="status" class="text-center text-gray-400 text-sm h-10 flex items-center justify-center">
                <p id="status-text">Please upload an image.</p>
                <div id="loader" class="loader hidden"></div>
            </div>
        </div>

        <div id="instructions-container" class="mt-8 hidden">
            <h2 class="text-lg font-bold text-gray-200 mb-2">Build Instructions</h2>
            <p class="text-xs text-gray-400 mb-4">A continuous path to create the art with one thread. Pins are numbered 1 to N.</p>
            <textarea id="continuous-path-sequence" readonly class="w-full h-32 bg-gray-800 text-gray-300 rounded-lg p-2 text-sm border border-gray-600 resize-none"></textarea>
            <button id="download-continuous-btn" class="w-full mt-2 bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg shadow-md">
                Download Path
            </button>
        </div>
    </div>

    <!-- CANVAS AREA -->
    <div class="canvas-container flex-grow p-6 grid grid-cols-1 md:grid-cols-2 gap-6 items-center justify-center overflow-auto">
        <div class="text-center">
            <h2 class="text-lg font-semibold mb-3 text-gray-300">Original (Grayscale)</h2>
            <canvas id="original-canvas" width="500" height="500" class="mx-auto rounded-lg shadow-lg"></canvas>
        </div>
        <div class="text-center">
            <h2 class="text-lg font-semibold mb-3 text-gray-300">Generated String Art</h2>
            <canvas id="string-art-canvas" width="500" height="500" class="mx-auto rounded-lg shadow-lg bg-white"></canvas>
        </div>
    </div>

    <script type="module">
        // --- DOM ELEMENT REFERENCES ---
        const imageUpload = document.getElementById('image-upload');
        const pinsInput = document.getElementById('pins');
        const threadCountInput = document.getElementById('thread-count');
        const canvasSizeInput = document.getElementById('canvas-size');
        const threadWidthInput = document.getElementById('thread-width');
        const startBtn = document.getElementById('start-btn');
        const stopBtn = document.getElementById('stop-btn');
        const statusText = document.getElementById('status-text');
        const loader = document.getElementById('loader');
        const instructionsContainer = document.getElementById('instructions-container');
        const continuousPathTextarea = document.getElementById('continuous-path-sequence');
        const downloadContinuousBtn = document.getElementById('download-continuous-btn');
        const originalCanvas = document.getElementById('original-canvas');
        const stringArtCanvas = document.getElementById('string-art-canvas');

        // --- GLOBAL STATE ---
        let worker = null;
        let isGenerating = false;

        // --- INITIALIZATION ---
        startBtn.disabled = true;

        // --- EVENT LISTENERS ---
        imageUpload.addEventListener('change', handleImageUpload);
        startBtn.addEventListener('click', startGeneration);
        stopBtn.addEventListener('click', stopGeneration);
        downloadContinuousBtn.addEventListener('click', downloadInstructions);

        function handleImageUpload(e) {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    const originalCtx = originalCanvas.getContext('2d');
                    originalCtx.fillStyle = 'white';
                    originalCtx.fillRect(0, 0, originalCanvas.width, originalCanvas.height);
                    
                    const aspectRatio = img.width / img.height;
                    let drawWidth = originalCanvas.width;
                    let drawHeight = originalCanvas.height;
                    if (aspectRatio > 1) {
                        drawHeight = drawWidth / aspectRatio;
                    } else {
                        drawWidth = drawHeight * aspectRatio;
                    }
                    const offsetX = (originalCanvas.width - drawWidth) / 2;
                    const offsetY = (originalCanvas.height - drawHeight) / 2;

                    originalCtx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
                    startBtn.disabled = false;
                    statusText.textContent = 'Ready to generate.';
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        }
        
        function startGeneration() {
            if (isGenerating) return;

            const originalCtx = originalCanvas.getContext('2d', { willReadFrequently: true });
            const imageData = originalCtx.getImageData(0, 0, originalCanvas.width, originalCanvas.height);

            if (!imageData) {
                alert("Please upload an image first.");
                return;
            }

            isGenerating = true;
            toggleControls(false);

            const settings = {
                pins: parseInt(pinsInput.value),
                threadCount: parseInt(threadCountInput.value),
                canvasSizeInches: parseFloat(canvasSizeInput.value),
                threadWidthMM: parseFloat(threadWidthInput.value),
                imageData: imageData,
            };

            const workerCode = `(${aiWorker.toString()})()`;
            const workerBlob = new Blob([workerCode], { type: 'application/javascript' });
            worker = new Worker(URL.createObjectURL(workerBlob));
            
            worker.onmessage = (e) => {
                const { type, payload } = e.data;
                switch (type) {
                    case 'PROGRESS':
                        updateUI(payload);
                        break;
                    case 'DONE':
                        isGenerating = false;
                        toggleControls(true);
                        updateUI(payload, true);
                        displayInstructions(payload.path);
                        worker.terminate();
                        worker = null;
                        break;
                    case 'ERROR':
                        isGenerating = false;
                        toggleControls(true);
                        alert('An error occurred in the worker: ' + payload.message);
                        worker.terminate();
                        worker = null;
                        break;
                }
            };
            
            worker.postMessage({ type: 'START', payload: settings });
        }

        function stopGeneration() {
            if (worker) {
                worker.terminate();
                worker = null;
            }
            isGenerating = false;
            toggleControls(true);
            statusText.textContent = 'Generation stopped by user.';
        }

        function toggleControls(enable) {
            startBtn.disabled = !enable;
            imageUpload.disabled = !enable;
            pinsInput.disabled = !enable;
            threadCountInput.disabled = !enable;
            canvasSizeInput.disabled = !enable;
            threadWidthInput.disabled = !enable;
            
            if (!enable) { // Generation starting
                startBtn.classList.add('hidden');
                stopBtn.classList.remove('hidden');
                loader.classList.remove('hidden');
                statusText.textContent = 'Initializing...';
                instructionsContainer.classList.add('hidden');
            } else { // Generation finished/stopped
                stopBtn.classList.add('hidden');
                startBtn.classList.remove('hidden');
                loader.classList.add('hidden');
            }
        }
        
        function updateUI({ strings, progress }, isDone = false) {
             statusText.textContent = isDone ? "Generation Complete!" : `Generating... String ${progress.current}/${progress.total}`;
             const stringArtCtx = stringArtCanvas.getContext('2d');
             stringArtCtx.fillStyle = 'white';
             stringArtCtx.fillRect(0, 0, stringArtCanvas.width, stringArtCanvas.height);
             stringArtCtx.putImageData(strings, 0, 0);
        }

        function displayInstructions(path) {
            if (path && path.length > 0) {
                // Convert 0-based path to 1-based path for display
                const oneBasedPath = path.map(pin => pin + 1);
                continuousPathTextarea.value = oneBasedPath.join(' -> ');
                instructionsContainer.classList.remove('hidden');
            }
        }
        
        function downloadInstructions() {
            const text = continuousPathTextarea.value;
            if (!text) return;

            const formattedText = text.replace(/ -> /g, '\n');
            const filename = 'string_art_path.txt';
            const blob = new Blob([formattedText], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // --- AI WORKER LOGIC ---
        // This function will be turned into a string and run in a separate thread.
        function aiWorker() {
            let CANVAS_SIZE, pins, errorMap, precomputedLines;
            
            self.onmessage = function(e) {
                const { type, payload } = e.data;
                if (type === 'START') {
                    try {
                        const result = runGenerator(payload);
                        self.postMessage({ type: 'DONE', payload: result });
                    } catch (error) {
                        self.postMessage({ type: 'ERROR', payload: { message: error.message } });
                    }
                }
            };
            
            function runGenerator(settings) {
                CANVAS_SIZE = settings.imageData.width;
                errorMap = createPerceptualMap(settings.imageData);
                pins = generatePins(settings.pins);
                precomputedLines = precomputeLines(pins);

                let currentPin = 0;
                const stringList = [];
                const threadWidthPixels = calculateThreadWidth(settings);

                for (let i = 0; i < settings.threadCount; i++) {
                    const bestLine = findBestNextLine(currentPin, precomputedLines);
                    
                    if (bestLine) {
                        stringList.push(bestLine);
                        updateErrorMap(bestLine, precomputedLines, threadWidthPixels);
                        currentPin = bestLine.nextPin;
                    } else {
                        currentPin = (currentPin + 37) % settings.pins;
                    }
                    
                    if (i % 100 === 0 || i === settings.threadCount - 1) {
                         const stringsImage = drawStrings(stringList, settings.imageData, threadWidthPixels);
                         self.postMessage({
                            type: 'PROGRESS',
                            payload: { strings: stringsImage, progress: { current: i + 1, total: settings.threadCount } }
                        });
                    }
                }
                
                const finalPath = solveContinuousPath(stringList);
                const finalImage = drawStrings(stringList, settings.imageData, threadWidthPixels);
                return { 
                    strings: finalImage, 
                    path: finalPath, 
                    progress: { current: settings.threadCount, total: settings.threadCount }
                };
            }
            
            function calculateThreadWidth(settings) {
                const canvasSizeInches = settings.canvasSizeInches;
                const threadWidthMM = settings.threadWidthMM;
                const pixelsPerInch = CANVAS_SIZE / canvasSizeInches;
                const threadWidthInches = threadWidthMM / 25.4;
                return Math.max(0.1, threadWidthInches * pixelsPerInch);
            }

            function createPerceptualMap(imageData) {
                const data = imageData.data;
                const width = imageData.width;
                const height = imageData.height;
                const grayscale = new Float32Array(width * height);
                const sobel = new Float32Array(width * height);
                const perceptualMap = new Float32Array(width * height);

                for (let i = 0; i < data.length; i += 4) {
                    const avg = (data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114);
                    grayscale[i / 4] = avg;
                }
                
                const kernelX = [[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]];
                const kernelY = [[-1, -2, -1], [0, 0, 0], [1, 2, 1]];
                let maxSobel = 0;
                for (let y = 1; y < height - 1; y++) {
                    for (let x = 1; x < width - 1; x++) {
                        let pixelX = 0, pixelY = 0;
                        for (let i = -1; i <= 1; i++) {
                            for (let j = -1; j <= 1; j++) {
                                const pixel = grayscale[(y + i) * width + (x + j)]; 
                                pixelX += pixel * kernelX[i + 1][j + 1];
                                pixelY += pixel * kernelY[i + 1][j + 1];
                            }
                        }
                        const magnitude = Math.sqrt(pixelX * pixelX + pixelY * pixelY);
                        const idx = y * width + x;
                        sobel[idx] = magnitude;
                        if (magnitude > maxSobel) maxSobel = magnitude;
                    }
                }
                
                const EDGE_BOOST = 1.5;
                for (let i = 0; i < perceptualMap.length; i++) {
                    const darkness = 255 - grayscale[i];
                    const edgeValue = sobel[i] / (maxSobel || 1);
                    perceptualMap[i] = darkness * (1 + edgeValue * EDGE_BOOST);
                }
                return perceptualMap;
            }

            function generatePins(numPins) {
                const p = [];
                const radius = CANVAS_SIZE / 2 - 5;
                const center = CANVAS_SIZE / 2;
                for (let i = 0; i < numPins; i++) {
                    const angle = (i / numPins) * 2 * Math.PI;
                    p.push({ x: Math.round(center + radius * Math.cos(angle)), y: Math.round(center + radius * Math.sin(angle)) });
                }
                return p;
            }
            
            function getLinePixels(x0, y0, x1, y1) {
                const pixels = [];
                const dx = Math.abs(x1 - x0), sx = x0 < x1 ? 1 : -1;
                const dy = -Math.abs(y1 - y0), sy = y0 < y1 ? 1 : -1;
                let err = dx + dy;
                while (true) {
                    if (x0 >= 0 && x0 < CANVAS_SIZE && y0 >= 0 && y0 < CANVAS_SIZE) {
                         pixels.push(y0 * CANVAS_SIZE + x0);
                    }
                    if (x0 === x1 && y0 === y1) break;
                    const e2 = 2 * err;
                    if (e2 >= dy) { err += dy; x0 += sx; }
                    if (e2 <= dx) { err += dx; y0 += sy; }
                }
                return pixels;
            }

            function precomputeLines(pins) {
                const lines = new Array(pins.length);
                for (let i = 0; i < pins.length; i++) {
                    lines[i] = new Array(pins.length);
                    for (let j = i + 1; j < pins.length; j++) {
                        lines[i][j] = getLinePixels(pins[i].x, pins[i].y, pins[j].x, pins[j].y);
                    }
                }
                return lines;
            }
            
            function findBestNextLine(currentPin, lines) {
                let bestNextPin = -1;
                let maxImprovement = -1;

                for (let nextPin = 0; nextPin < pins.length; nextPin++) {
                    if (nextPin === currentPin) continue;

                    const p1 = Math.min(currentPin, nextPin);
                    const p2 = Math.max(currentPin, nextPin);
                    
                    const linePixels = lines[p1]?.[p2];
                    if (!linePixels) continue;

                    let improvement = 0;
                    for (const idx of linePixels) {
                        improvement += errorMap[idx];
                    }

                    if (improvement > maxImprovement) {
                        maxImprovement = improvement;
                        bestNextPin = nextPin;
                    }
                }
                
                if (bestNextPin !== -1) {
                    const p1 = Math.min(currentPin, bestNextPin);
                    const p2 = Math.max(currentPin, bestNextPin);
                    return { p1, p2, nextPin: bestNextPin };
                }
                return null;
            }

            function updateErrorMap(line, lines, threadWidth) {
                const linePixels = lines[line.p1]?.[line.p2];
                if (!linePixels) return;
                const darknessImpact = 30 * threadWidth; 
                for (const idx of linePixels) {
                    errorMap[idx] = Math.max(0, errorMap[idx] - darknessImpact);
                }
            }
            
            function drawStrings(stringList, originalImageData, lineWidth) {
                const tempCanvas = new OffscreenCanvas(CANVAS_SIZE, CANVAS_SIZE);
                const ctx = tempCanvas.getContext('2d');

                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
                ctx.strokeStyle = 'black';
                ctx.lineWidth = lineWidth;
                ctx.lineCap = 'round';

                for (const s of stringList) {
                    ctx.beginPath();
                    ctx.moveTo(pins[s.p1].x, pins[s.p1].y);
                    ctx.lineTo(pins[s.p2].x, pins[s.p2].y);
                    ctx.stroke();
                }
                return ctx.getImageData(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            }
            
            function solveContinuousPath(stringList) {
                if (stringList.length === 0) return [];
                const path = [stringList[0].p1];
                let currentPin = stringList[0].p1;

                for(const s of stringList) {
                    if (s.p1 === currentPin) {
                        path.push(s.p2);
                        currentPin = s.p2;
                    } else if (s.p2 === currentPin) {
                        path.push(s.p1);
                        currentPin = s.p1;
                    } else {
                        // This indicates a break in the path, which shouldn't happen
                        // with the sequential greedy algorithm. We jump to the new start.
                        path.push(s.p1);
                        path.push(s.p2);
                        currentPin = s.p2;
                    }
                }
                return path;
            }
        }
    </script>
</body>
</html>

